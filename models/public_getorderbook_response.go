// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PublicGetorderbookResponse public getorderbook response
// swagger:model public_getorderbook_response
type PublicGetorderbookResponse struct {

	// result
	// Required: true
	Result *PublicGetorderbookResponseResult `json:"result"`
}

// Validate validates this public getorderbook response
func (m *PublicGetorderbookResponse) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateResult(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PublicGetorderbookResponse) validateResult(formats strfmt.Registry) error {

	if err := validate.Required("result", "body", m.Result); err != nil {
		return err
	}

	if m.Result != nil {
		if err := m.Result.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("result")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PublicGetorderbookResponse) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PublicGetorderbookResponse) UnmarshalBinary(b []byte) error {
	var res PublicGetorderbookResponse
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PublicGetorderbookResponseResult public getorderbook response result
// swagger:model PublicGetorderbookResponseResult
type PublicGetorderbookResponseResult struct {

	// (Only for option) implied volatility for best ask
	// Required: true
	AskIv *float64 `json:"askIv"`

	// The list of all asks, best ask first. See below for entry details
	// Required: true
	Asks []string `json:"asks"`

	// (Only for option) implied volatility for best bid
	// Required: true
	BidIv *float64 `json:"bidIv"`

	// The list of all bids, best bid first. See below for entry details
	// Required: true
	Bids []string `json:"bids"`

	// The cumulative quantity
	// Required: true
	Cm *float64 `json:"cm"`

	// The settlement price for this instrument. Only when `state=closed`
	// Required: true
	DeliveryPrice *float64 `json:"deliveryPrice"`

	// (Only for options) The delta value for the option
	// Required: true
	Delta *float64 `json:"delta"`

	// (Only for options) The gamma value for the option
	// Required: true
	Gamma *float64 `json:"gamma"`

	// The 24h high for the instrument
	// Required: true
	High *float64 `json:"high"`

	// (Only for option) Interest rate used for implied volatility calculations
	// Required: true
	IR *float64 `json:"iR"`

	// The name of the instrument.
	// Required: true
	Instrument *string `json:"instrument"`

	// The price for the last trade
	// Required: true
	Last *float64 `json:"last"`

	// The 24h low for the instrument
	// Required: true
	Low *float64 `json:"low"`

	// The mark price for the instrument
	// Required: true
	Mark *float64 `json:"mark"`

	// (Only for option) implied volatility for mark price
	// Required: true
	MarkIv *float64 `json:"markIv"`

	// (Only for futures) The maximum price for the future. Any buy orders you submit higher than this price, will be clamped to this maximum.
	// Required: true
	Max *float64 `json:"max"`

	// (Only for futures) The minimum price for the future. Any sell orders you submit lower than this price will be clamped to this minimum.
	// Required: true
	Min *float64 `json:"min"`

	// (Only for options)The order id of an unfilled order you have at this price. This field only shows if you have an order at this price level, and the request has been [signed](rpc-authentication.md).
	// Required: true
	Oid *float64 `json:"oid"`

	// The price level
	// Required: true
	Price *float64 `json:"price"`

	// The total quantity of orders for this price level
	// Required: true
	Quantity *float64 `json:"quantity"`

	// The settlement price for this instrument. Only when `state=open`
	// Required: true
	SettlementPrice *float64 `json:"settlementPrice"`

	// The state of the order book. Possible values are `"open"` and `"closed"`.
	// Required: true
	State *string `json:"state"`

	// (Only for option) The theta value for the option
	// Required: true
	Theta *float64 `json:"theta"`

	// The order book timestamp in milliseconds
	// Required: true
	Tstamp *int64 `json:"tstamp"`

	// (Only for option) underlying future instrument name or `"index_price"`
	// Required: true
	UIx *float64 `json:"uIx"`

	// (Only for option) underlying price used for ask/bid implied volatility
	// Required: true
	UPx *float64 `json:"uPx"`

	// (Only for option) The vega value for the option
	// Required: true
	Vega *float64 `json:"vega"`
}

// Validate validates this public getorderbook response result
func (m *PublicGetorderbookResponseResult) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAskIv(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAsks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBidIv(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBids(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCm(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeliveryPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDelta(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGamma(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHigh(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIR(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstrument(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLast(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLow(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMark(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMarkIv(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMax(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMin(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOid(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQuantity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSettlementPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTheta(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTstamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUIx(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUPx(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVega(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PublicGetorderbookResponseResult) validateAskIv(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"askIv", "body", m.AskIv); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateAsks(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"asks", "body", m.Asks); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateBidIv(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"bidIv", "body", m.BidIv); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateBids(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"bids", "body", m.Bids); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateCm(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"cm", "body", m.Cm); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateDeliveryPrice(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"deliveryPrice", "body", m.DeliveryPrice); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateDelta(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"delta", "body", m.Delta); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateGamma(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"gamma", "body", m.Gamma); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateHigh(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"high", "body", m.High); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateIR(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"iR", "body", m.IR); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateInstrument(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"instrument", "body", m.Instrument); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateLast(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"last", "body", m.Last); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateLow(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"low", "body", m.Low); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateMark(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"mark", "body", m.Mark); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateMarkIv(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"markIv", "body", m.MarkIv); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateMax(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"max", "body", m.Max); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateMin(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"min", "body", m.Min); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateOid(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"oid", "body", m.Oid); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validatePrice(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"price", "body", m.Price); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateQuantity(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"quantity", "body", m.Quantity); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateSettlementPrice(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"settlementPrice", "body", m.SettlementPrice); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateState(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateTheta(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"theta", "body", m.Theta); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateTstamp(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"tstamp", "body", m.Tstamp); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateUIx(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"uIx", "body", m.UIx); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateUPx(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"uPx", "body", m.UPx); err != nil {
		return err
	}

	return nil
}

func (m *PublicGetorderbookResponseResult) validateVega(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"vega", "body", m.Vega); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PublicGetorderbookResponseResult) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PublicGetorderbookResponseResult) UnmarshalBinary(b []byte) error {
	var res PublicGetorderbookResponseResult
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
