// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PrivateSettlementhistoryResponse private settlementhistory response
// swagger:model private_settlementhistory_response
type PrivateSettlementhistoryResponse struct {

	// result
	// Required: true
	Result *PrivateSettlementhistoryResponseResult `json:"result"`
}

// Validate validates this private settlementhistory response
func (m *PrivateSettlementhistoryResponse) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateResult(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PrivateSettlementhistoryResponse) validateResult(formats strfmt.Registry) error {

	if err := validate.Required("result", "body", m.Result); err != nil {
		return err
	}

	if m.Result != nil {
		if err := m.Result.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("result")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PrivateSettlementhistoryResponse) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PrivateSettlementhistoryResponse) UnmarshalBinary(b []byte) error {
	var res PrivateSettlementhistoryResponse
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PrivateSettlementhistoryResponseResult private settlementhistory response result
// swagger:model PrivateSettlementhistoryResponseResult
type PrivateSettlementhistoryResponseResult struct {

	// Funded amount (bankruptcy only)
	// Required: true
	Funded *string `json:"funded"`

	// Underlying index price at time of event (settlement and delivery only)
	// Required: true
	IndexPrice *float64 `json:"indexPrice"`

	// instrument name (settlement and delivery only)
	// Required: true
	Instrument *string `json:"instrument"`

	// Mark price for at the time  (settlement and delivery only)
	// Required: true
	MarkPrice *float64 `json:"markPrice"`

	// position size  (settlement and delivery only)
	// Required: true
	Position *string `json:"position"`

	// profit and loss (settlement and delivery only)
	// Required: true
	ProfitLoss *float64 `json:"profitLoss"`

	// in BTC
	// Required: true
	SessionBankrupcy *float64 `json:"sessionBankrupcy"`

	// session profit loss
	// Required: true
	SessionProfitLoss *string `json:"sessionProfitLoss"`

	// in BTC
	// Required: true
	SessionTax *float64 `json:"sessionTax"`

	// in BTC
	// Required: true
	SessionTaxRate *float64 `json:"sessionTaxRate"`

	// The amount of the losses socialized
	// Required: true
	Socialized *float64 `json:"socialized"`

	// The timestamp of the settlement
	// Required: true
	TimeStamp *int64 `json:"timeStamp"`

	// type
	// Required: true
	Type SettlementType `json:"type"`
}

// Validate validates this private settlementhistory response result
func (m *PrivateSettlementhistoryResponseResult) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFunded(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIndexPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstrument(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMarkPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePosition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProfitLoss(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSessionBankrupcy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSessionProfitLoss(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSessionTax(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSessionTaxRate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSocialized(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimeStamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PrivateSettlementhistoryResponseResult) validateFunded(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"funded", "body", m.Funded); err != nil {
		return err
	}

	return nil
}

func (m *PrivateSettlementhistoryResponseResult) validateIndexPrice(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"indexPrice", "body", m.IndexPrice); err != nil {
		return err
	}

	return nil
}

func (m *PrivateSettlementhistoryResponseResult) validateInstrument(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"instrument", "body", m.Instrument); err != nil {
		return err
	}

	return nil
}

func (m *PrivateSettlementhistoryResponseResult) validateMarkPrice(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"markPrice", "body", m.MarkPrice); err != nil {
		return err
	}

	return nil
}

func (m *PrivateSettlementhistoryResponseResult) validatePosition(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"position", "body", m.Position); err != nil {
		return err
	}

	return nil
}

func (m *PrivateSettlementhistoryResponseResult) validateProfitLoss(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"profitLoss", "body", m.ProfitLoss); err != nil {
		return err
	}

	return nil
}

func (m *PrivateSettlementhistoryResponseResult) validateSessionBankrupcy(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"sessionBankrupcy", "body", m.SessionBankrupcy); err != nil {
		return err
	}

	return nil
}

func (m *PrivateSettlementhistoryResponseResult) validateSessionProfitLoss(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"sessionProfitLoss", "body", m.SessionProfitLoss); err != nil {
		return err
	}

	return nil
}

func (m *PrivateSettlementhistoryResponseResult) validateSessionTax(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"sessionTax", "body", m.SessionTax); err != nil {
		return err
	}

	return nil
}

func (m *PrivateSettlementhistoryResponseResult) validateSessionTaxRate(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"sessionTaxRate", "body", m.SessionTaxRate); err != nil {
		return err
	}

	return nil
}

func (m *PrivateSettlementhistoryResponseResult) validateSocialized(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"socialized", "body", m.Socialized); err != nil {
		return err
	}

	return nil
}

func (m *PrivateSettlementhistoryResponseResult) validateTimeStamp(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"timeStamp", "body", m.TimeStamp); err != nil {
		return err
	}

	return nil
}

func (m *PrivateSettlementhistoryResponseResult) validateType(formats strfmt.Registry) error {

	if err := m.Type.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("result" + "." + "type")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PrivateSettlementhistoryResponseResult) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PrivateSettlementhistoryResponseResult) UnmarshalBinary(b []byte) error {
	var res PrivateSettlementhistoryResponseResult
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
