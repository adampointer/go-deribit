// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// UserTrade user trade
// swagger:model user_trade
type UserTrade struct {

	// Trade amount. For perpetual and futures - in USD units, for options it is amount of corresponding cryptocurrency contracts, e.g., BTC or ETH.
	// Required: true
	Amount *float64 `json:"amount"`

	// Trade direction of the taker
	// Required: true
	Direction Direction `json:"direction"`

	// User's fee in units of the specified `fee_currency`
	// Required: true
	Fee *float64 `json:"fee"`

	// fee currency
	// Required: true
	FeeCurrency Currency `json:"fee_currency"`

	// Index Price at the moment of trade
	// Required: true
	IndexPrice *float64 `json:"index_price"`

	// instrument name
	// Required: true
	InstrumentName InstrumentName `json:"instrument_name"`

	// Option implied volatility for the price (Option only)
	Iv float64 `json:"iv,omitempty"`

	// User defined label (presented only when previously set for order by user)
	Label string `json:"label,omitempty"`

	// Optional field (only for trades caused by liquidation): `"M"` when maker side of trade was under liquidation, `"T"` when taker side was under liquidation, `"MT"` when both sides of trade were under liquidation
	// Enum: [M T MT]
	Liquidation string `json:"liquidation,omitempty"`

	// Describes what was role of users order: `"M"` when it was maker order, `"T"` when it was taker order
	// Enum: [M T]
	Liquidity string `json:"liquidity,omitempty"`

	// Always `null`, except for a self-trade which is possible only if self-trading is switched on for the account (in that case this will be id of the maker order of the subscriber)
	// Required: true
	MatchingID *string `json:"matching_id"`

	// Id of the user order (maker or taker), i.e. subscriber's order id that took part in the trade
	// Required: true
	OrderID *string `json:"order_id"`

	// Order type: `"limit`, `"market"`, or `"liquidation"`
	// Enum: [limit market liquidation]
	OrderType string `json:"order_type,omitempty"`

	// The price of the trade
	// Required: true
	Price Price `json:"price"`

	// `true` if the trade is against own order. This can only happen when your account has self-trading enabled. Contact an administrator if you think you need that
	// Required: true
	SelfTrade *bool `json:"self_trade"`

	// state
	// Required: true
	State OrderStateInUserTrade `json:"state"`

	// tick direction
	// Required: true
	TickDirection TickDirection `json:"tick_direction"`

	// The timestamp of the trade
	// Required: true
	Timestamp *int64 `json:"timestamp"`

	// trade id
	// Required: true
	TradeID TradeID `json:"trade_id"`

	// trade seq
	// Required: true
	TradeSeq TradeSeq `json:"trade_seq"`
}

// Validate validates this user trade
func (m *UserTrade) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDirection(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFee(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFeeCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIndexPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstrumentName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLiquidation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLiquidity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMatchingID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelfTrade(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTickDirection(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTradeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTradeSeq(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UserTrade) validateAmount(formats strfmt.Registry) error {

	if err := validate.Required("amount", "body", m.Amount); err != nil {
		return err
	}

	return nil
}

func (m *UserTrade) validateDirection(formats strfmt.Registry) error {

	if err := m.Direction.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("direction")
		}
		return err
	}

	return nil
}

func (m *UserTrade) validateFee(formats strfmt.Registry) error {

	if err := validate.Required("fee", "body", m.Fee); err != nil {
		return err
	}

	return nil
}

func (m *UserTrade) validateFeeCurrency(formats strfmt.Registry) error {

	if err := m.FeeCurrency.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("fee_currency")
		}
		return err
	}

	return nil
}

func (m *UserTrade) validateIndexPrice(formats strfmt.Registry) error {

	if err := validate.Required("index_price", "body", m.IndexPrice); err != nil {
		return err
	}

	return nil
}

func (m *UserTrade) validateInstrumentName(formats strfmt.Registry) error {

	if err := m.InstrumentName.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("instrument_name")
		}
		return err
	}

	return nil
}

var userTradeTypeLiquidationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["M","T","MT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		userTradeTypeLiquidationPropEnum = append(userTradeTypeLiquidationPropEnum, v)
	}
}

const (

	// UserTradeLiquidationM captures enum value "M"
	UserTradeLiquidationM string = "M"

	// UserTradeLiquidationT captures enum value "T"
	UserTradeLiquidationT string = "T"

	// UserTradeLiquidationMT captures enum value "MT"
	UserTradeLiquidationMT string = "MT"
)

// prop value enum
func (m *UserTrade) validateLiquidationEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, userTradeTypeLiquidationPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *UserTrade) validateLiquidation(formats strfmt.Registry) error {

	if swag.IsZero(m.Liquidation) { // not required
		return nil
	}

	// value enum
	if err := m.validateLiquidationEnum("liquidation", "body", m.Liquidation); err != nil {
		return err
	}

	return nil
}

var userTradeTypeLiquidityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["M","T"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		userTradeTypeLiquidityPropEnum = append(userTradeTypeLiquidityPropEnum, v)
	}
}

const (

	// UserTradeLiquidityM captures enum value "M"
	UserTradeLiquidityM string = "M"

	// UserTradeLiquidityT captures enum value "T"
	UserTradeLiquidityT string = "T"
)

// prop value enum
func (m *UserTrade) validateLiquidityEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, userTradeTypeLiquidityPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *UserTrade) validateLiquidity(formats strfmt.Registry) error {

	if swag.IsZero(m.Liquidity) { // not required
		return nil
	}

	// value enum
	if err := m.validateLiquidityEnum("liquidity", "body", m.Liquidity); err != nil {
		return err
	}

	return nil
}

func (m *UserTrade) validateMatchingID(formats strfmt.Registry) error {

	if err := validate.Required("matching_id", "body", m.MatchingID); err != nil {
		return err
	}

	return nil
}

func (m *UserTrade) validateOrderID(formats strfmt.Registry) error {

	if err := validate.Required("order_id", "body", m.OrderID); err != nil {
		return err
	}

	return nil
}

var userTradeTypeOrderTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["limit","market","liquidation"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		userTradeTypeOrderTypePropEnum = append(userTradeTypeOrderTypePropEnum, v)
	}
}

const (

	// UserTradeOrderTypeLimit captures enum value "limit"
	UserTradeOrderTypeLimit string = "limit"

	// UserTradeOrderTypeMarket captures enum value "market"
	UserTradeOrderTypeMarket string = "market"

	// UserTradeOrderTypeLiquidation captures enum value "liquidation"
	UserTradeOrderTypeLiquidation string = "liquidation"
)

// prop value enum
func (m *UserTrade) validateOrderTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, userTradeTypeOrderTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *UserTrade) validateOrderType(formats strfmt.Registry) error {

	if swag.IsZero(m.OrderType) { // not required
		return nil
	}

	// value enum
	if err := m.validateOrderTypeEnum("order_type", "body", m.OrderType); err != nil {
		return err
	}

	return nil
}

func (m *UserTrade) validatePrice(formats strfmt.Registry) error {

	if err := m.Price.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("price")
		}
		return err
	}

	return nil
}

func (m *UserTrade) validateSelfTrade(formats strfmt.Registry) error {

	if err := validate.Required("self_trade", "body", m.SelfTrade); err != nil {
		return err
	}

	return nil
}

func (m *UserTrade) validateState(formats strfmt.Registry) error {

	if err := m.State.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("state")
		}
		return err
	}

	return nil
}

func (m *UserTrade) validateTickDirection(formats strfmt.Registry) error {

	if err := m.TickDirection.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("tick_direction")
		}
		return err
	}

	return nil
}

func (m *UserTrade) validateTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

func (m *UserTrade) validateTradeID(formats strfmt.Registry) error {

	if err := m.TradeID.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("trade_id")
		}
		return err
	}

	return nil
}

func (m *UserTrade) validateTradeSeq(formats strfmt.Registry) error {

	if err := m.TradeSeq.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("trade_seq")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *UserTrade) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *UserTrade) UnmarshalBinary(b []byte) error {
	var res UserTrade
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
